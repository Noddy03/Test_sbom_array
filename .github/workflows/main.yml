name: Universal SBOM Pipeline (High Quality)

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]
  workflow_dispatch:
    inputs:
      language:
        description: "Language filter for deep scan (e.g. C++, Python, Java). Use 'none' to skip."
        required: true
        default: "C++"

jobs:
  sbom_pipeline:
    runs-on: ubuntu-latest
    steps:
    - name: ‚¨áÔ∏è Checkout Repository
      uses: actions/checkout@v4

    # ----------------------------------------------------
    # 1. CORE SCANNERS (Trivy as Main Baseline, Syft as Enrichment)
    # ----------------------------------------------------
    # Syft (Enrichment): Provides a high-quality, comprehensive list of files and dependencies.
    - name: üì¶ Generate SBOM with Syft (Filesystem)
      uses: anchore/syft-action/source@v0.19.0
      with:
        output: "cyclonedx-json"
        file: "syft-sbom.json"

    # Trivy (Main Analyser/Baseline): Scans filesystem for OS packages and file dependencies.
    - name: üõ°Ô∏è Generate SBOM with Trivy (Filesystem/Vulnerabilities)
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        format: 'cyclonedx-json'
        output: 'trivy-fs.json'
        vuln-type: 'os,library'
        security-checks: 'vuln'
        output-path: 'vulnerabilities_fs.json'

    # ----------------------------------------------------
    # 2. LANGUAGE-SPECIFIC DEEP SCANS (CDXGen as Main, Conan as Optional)
    # ----------------------------------------------------
    - name: üêç Setup Python for Deep Scans & Merge Script
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: ‚öôÔ∏è Install Global NPM Dependencies for CDXGen/Conan
      run: |
        npm install -g @cyclonedx/cdxgen

    # CDXGen (Main Deep Scanner)
    - name: ‚öôÔ∏è Optional Deep Scan (CDXGen: ${{ github.event.inputs.language }})
      id: cdxgen_scan
      # Run if the input is a standard language (not C/C++ or none)
      if: |
        github.event.inputs.language != '' && 
        github.event.inputs.language != 'none' && 
        !startsWith(github.event.inputs.language, 'C') &&
        !startsWith(github.event.inputs.language, 'c')
      run: |
        LANG_INPUT="${{ github.event.inputs.language }}"
        LANG=$(echo "$LANG_INPUT" | tr '[:upper:]' '[:lower:]')
        OUTPUT_FILE="cdxgen-${LANG}-sbom.json"
        
        # Install JDK if needed for Java/Maven/Gradle projects
        if [ "$LANG" == "java" ]; then
            sudo apt-get update && sudo apt-get install -y default-jdk
        fi
        
        cdxgen -o "$OUTPUT_FILE" --type "$LANG"

        echo "CDXGEN_OUTPUT_FILE=$OUTPUT_FILE" >> $GITHUB_ENV
        echo "sbom_file_exists=true" >> $GITHUB_OUTPUT
      continue-on-error: true

    # Conan (Optional C/C++ Scanner)
    - name: ‚öôÔ∏è Optional C/C++ Deep Scan (Conan)
      id: conan_scan
      # Run specifically if C, C++, or similar is requested
      if: |
        startsWith(github.event.inputs.language, 'C') ||
        startsWith(github.event.inputs.language, 'c')
      run: |
        CONAN_FILE="conan-sbom.json"
        
        # Install necessary tools
        pip install conan
        
        # Run cdxgen against the source directory, leveraging its native support for Conan lockfiles
        # NOTE: This assumes a conanfile or lockfile exists in the root.
        cdxgen -o "$CONAN_FILE" --type cpp

        echo "CONAN_OUTPUT_FILE=$CONAN_FILE" >> $GITHUB_ENV
        echo "sbom_file_exists=true" >> $GITHUB_OUTPUT
      continue-on-error: true


    # ----------------------------------------------------
    # 3. DATA ENRICHMENT AND MERGING (The Quality Fix)
    # ----------------------------------------------------
    - name: ‚öôÔ∏è Install Python Dependencies for Merge
      run: pip install jsonpath-ng

   - name: üìù Create & Run SBOM Merge Script (Supplier/Timestamp Fix)
  id: merge_and_enrich
  env:
    REPO_NAME: ${{ github.repository }}
    CDXGEN_FILE: ${{ steps.cdxgen_scan.outputs.sbom_file_exists && env.CDXGEN_OUTPUT_FILE || '' }}
    CONAN_FILE: ${{ steps.conan_scan.outputs.sbom_file_exists && env.CONAN_OUTPUT_FILE || '' }} # Collect Conan output
  run: |
    cat << 'EOF' > merged_and_enrich.py
import json
import re
import os
from datetime import datetime

def normalize_component(component, default_supplier):
    """Enriches a component with necessary fields (Supplier) based on PURL to fix NTIA compliance."""
    purl = component.get("purl", "")
    supplier_name = ""

    # 1. Keep a valid supplier if already set by the scanner (highest confidence)
    existing_supplier = component.get("supplier", {}).get("name", "")
    if existing_supplier and existing_supplier.lower() != default_supplier.lower():
        return component

    # 2. Infer supplier from PURL (Critical Fix for NTIA/High Quality)
    if purl:
        purl_match = re.match(r"pkg:(\w+)/([\w\-\.]+)/?([^@\?#]*)", purl)
        if purl_match:
            pkg_type = purl_match.group(1)
            namespace = purl_match.group(2)
            
            # Ecosystem/Vendor Specific Logic 
            if pkg_type == "github":
                org_map = {
                    "actions": "GitHub, Inc. (Official Actions)", 
                    "arduino": "Arduino LLC", 
                    "codecov": "Codecov, Inc."
                }
                if namespace in org_map:
                    supplier_name = org_map[namespace]
                else:
                    supplier_name = f"{namespace} (via GitHub)"

            elif pkg_type in ["maven", "pypi", "npm", "nuget", "golang"]:
                # High-confidence supplier for common package ecosystems
                supplier_map = {
                    "maven": "Maven Central Repository",
                    "pypi": "Python Software Foundation",
                    "npm": "npm, Inc.",
                    "nuget": "Microsoft Corporation",
                    "golang": "Google LLC"
                }
                supplier_name = supplier_map.get(pkg_type, namespace)
            
            elif namespace:
                 supplier_name = namespace

    # 3. Apply the inferred supplier, or fall back to the project name
    if supplier_name:
        component["supplier"] = {"name": supplier_name}
    elif not component.get("supplier"):
        component["supplier"] = {"name": default_supplier}
        
    return component

def merge_and_enrich(files, default_supplier):
    sboms = []
    for f in files:
        if not f or not os.path.exists(f):
            continue
        try:
            with open(f, 'r') as fp:
                sbom_data = json.load(fp)
                if isinstance(sbom_data, dict):
                    sboms.append(sbom_data)
        except Exception as e:
            print(f"Warning: {f} could not be loaded or decoded. Error: {e}")
            
    if not sboms:
        print("Error: No valid SBOM files found for merging.")
        return None

    merged_sbom = sboms[0]
    
    merged_sbom['metadata']['timestamp'] = datetime.now().isoformat() + 'Z'
    merged_sbom['metadata']['component']['supplier'] = {"name": default_supplier}
    
    # Deduplicate and normalize components
    component_map = {}
    for sbom in sboms:
        if 'components' in sbom:
            for c in sbom['components']:
                ref = c.get("bom-ref", c.get("purl", c.get("name")))
                if ref and ref not in component_map:
                    component_map[ref] = c

    final_components = [normalize_component(c, default_supplier) for c in component_map.values()]

    merged_sbom['components'] = final_components
    
    return merged_sbom

if __name__ == "__main__":
    # Collect core and optional SBOMs
    SBOM_FILES = ["syft-sbom.json", "trivy-fs.json"] 
    
    cdxgen_file = os.environ.get("CDXGEN_FILE")
    if cdxgen_file:
        SBOM_FILES.append(cdxgen_file)
        
    conan_file = os.environ.get("CONAN_FILE")
    if conan_file:
        SBOM_FILES.append(conan_file)
        
    DEFAULT_SUPPLIER = os.environ.get("REPO_NAME")

    merged_data = merge_and_enrich(SBOM_FILES, DEFAULT_SUPPLIER)

    if merged_data:
        with open('merged-sbom.json', 'w') as f:
            json.dump(merged_data, f, indent=2)
        print("‚úÖ Successfully generated merged-sbom.json")
    else:
        print("‚ùå Failed to generate merged SBOM. Exiting.")
        exit(1)
        
EOF
    python merged_and_enrich.py

    # ----------------------------------------------------
    # 4. COMPLIANCE, SCORING, AND VULNERABILITY CHECKS (Trivy as Main Analyser)
    # ----------------------------------------------------
    - name: üíØ Check Quality Score (SBOMQS)
      uses: interlynk-io/sbomqs-action@v0.0.1
      with:
        input-file: merged-sbom.json
        output-file: score.json
        continue-on-error: true 

    - name: üìú Check NTIA Compliance (SBOMQS)
      uses: interlynk-io/sbomqs-action@v0.0.1
      with:
        input-file: merged-sbom.json
        output-file: compliance_NTIA.json
        profile: ntia
        continue-on-error: true 

    - name: üè∞ Check BSI V2 Compliance (SBOMQS)
      uses: interlynk-io/sbomqs-action@v0.0.1
      with:
        input-file: merged-sbom.json
        output-file: compliance_BSI.json
        profile: bsi
        continue-on-error: true 

    # Trivy's final role: Main Analyser for Vulnerabilities against the merged SBOM
    - name: ü™± Scan for Vulnerabilities in Merged SBOM (Trivy)
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'sbom'
        input: 'merged-sbom.json'
        format: 'json'
        output: 'vulnerabilities_sbom.json'
        continue-on-error: true

    # ----------------------------------------------------
    # 5. FINAL AGGREGATION AND REPORTING
    # ----------------------------------------------------
    - name: üìä Aggregate Final Summary
      id: aggregate_summary
      run: |
        sudo apt-get install -y jq bc
        
        # Safely extract scores, defaulting to 'error' if file is missing
        NTIA_SCORE=$(jq -r '.summary.total_score // "error"' compliance_NTIA.json 2>/dev/null || echo "error")
        BSI_SCORE=$(jq -r '.summary.total_score // "error"' compliance_BSI.json 2>/dev/null || echo "error")
        OVERALL_SCORE=$(jq -r '.files[0].sbom_quality_score // "error"' score.json 2>/dev/null || echo "error")

        # Safely extract vuln counts from the SBOM scan, defaulting to 0
        VULN_TOTAL=$(jq '[.Results[] | .Vulnerabilities | length] | add' vulnerabilities_sbom.json 2>/dev/null || echo 0)
        VULN_HIGH=$(jq '[.Results[] | .Vulnerabilities[] | select(.Severity == "HIGH") ] | length' vulnerabilities_sbom.json 2>/dev/null || echo 0)
        VULN_CRITICAL=$(jq '[.Results[] | .Vulnerabilities[] | select(.Severity == "CRITICAL") ] | length' vulnerabilities_sbom.json 2>/dev/null || echo 0)
        
        # Get component count and repo metadata
        COMPONENT_COUNT=$(jq '.components | length' merged-sbom.json 2>/dev/null || echo 0)
        REPO_LICENSE=$(jq -r '.metadata.component.licenses[0].license.id' merged-sbom.json 2>/dev/null || echo "N/A")

        # Generate simplified pass/fail (NTIA pass > 9.0, BSI pass > 5.0)
        NTIA_PASS_STATUS=$([ "$(echo "$NTIA_SCORE > 9.0" | bc -l)" -eq 1 ] && echo "pass" || echo "fail")
        BSI_PASS_STATUS=$([ "$(echo "$BSI_SCORE > 5.0" | bc -l)" -eq 1 ] && echo "pass" || echo "fail")

        # Create/Update the summary CSV
        SUMMARY_HEADER="repo,repo_license,component_count,vuln_sbom_total,vuln_high,vuln_critical,score_value,ntia_pass,bsi_pass"
        SUMMARY_DATA="${{ github.repository }},$REPO_LICENSE,$COMPONENT_COUNT,$VULN_TOTAL,$VULN_HIGH,$VULN_CRITICAL,$OVERALL_SCORE,$NTIA_PASS_STATUS,$BSI_PASS_STATUS"
        
        echo "$SUMMARY_HEADER" > summary.csv
        echo "$SUMMARY_DATA" >> summary.csv
        
    - name: üì§ Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: sbom-reports-high-quality
        path: |
          merged-sbom.json
          score.json
          compliance_NTIA.json
          compliance_BSI.json
          vulnerabilities_fs.json
          vulnerabilities_sbom.json
          summary.csv
          cdxgen-*-sbom.json
          conan-sbom.json
